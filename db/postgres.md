
### Какие бывают индексы в Postgres?

1. **PRIMARY KEY:** (первичный ключ)
   - Аналогично MySQL. Автоматически создаётся индекс B-Tree, обеспечивает уникальность, не допускает NULL.
2. **UNIQUE INDEX:** (уникальный индекс)
   - Аналогично MySQL. Поддерживает несколько NULL, поскольку PostgreSQL считает NULL неопределённым значением.
3. **INDEX:** (обычный индекс)
   - Аналогично MySQL. Создаётся B-Tree для ускорения поиска и сортировки.
4. **FULLTEXT INDEX:** (полнотекстовый индекс)
   - В PostgreSQL аналог реализован через механизм `GIN` (Generalized Inverted Index) и tsvector.
   - Поддерживает полнотекстовый поиск на более продвинутом уровне (с токенизацией, синонимами, ранжированием результатов и т.д.).
   - Поддерживает NULL.
   - Поддерживается токенизация, нормализация слов, работа с языковыми словарями и ранжирование результатов.
5. **SPATIAL INDEX:** (пространственный индекс)
   - Реализован с использованием `GiST` (Generalized Search Tree).
   - PostgreSQL изначально ориентирован на работу с геоданными благодаря расширению PostGIS, которое поддерживает многие пространственные операции.
6. **COMPOSITE INDEX:** (составной индекс)
   - Аналогично MySQL. Использует порядок колонок для оптимизации запросов. Например, `(A, B)` эффективно для `WHERE A = ? AND B = ?`, но не для `WHERE B = ?`.
7. **HASH INDEX:**
   - Аналогично MySQL. Становится полезным только для точных сравнений `=`.
8. **CLUSTERED INDEX:**
   - PostgreSQL использует схожий подход, но не называет его "Clustered Index".
   Таблица физически упорядочивается по любому индексу с помощью команды `CLUSTER`. 
   Но поддержание порядка не автоматизировано, требуется периодическое выполнение команды.
   ```sql
   CLUSTER your_table USING your_index; 
   ```
9. **FOREIGN KEY INDEX:**
   - В отличие от MySQL, PostgreSQL не создаёт индекс автоматически при добавлении внешнего ключа.
   Для ускорения JOIN или поиска по внешнему ключу индекс нужно создавать вручную.
10. **PREFIX KEY INDEX:**
    - PostgreSQL поддерживает индексацию по префиксу строки с использованием выражений:
    ```sql
    CREATE INDEX idx_email_prefix ON users (LEFT(email, 10));
    ```
    Аналогично MySQL, подходит для запросов с LIKE 'abc%'.

### Важные отличия от Mysql

В PostgreSQL директива autovacuum включена по умолчанию, и она автоматически управляет процессами VACUUM и ANALYZE для 
поддержания производительности базы данных.

**VACUUM** - очищает таблицы от мертвых строк, освобождает место и помогает предотвратить фрагментацию.
**ANALYZE** - собирает статистику для оптимизации запросов.
**VACUUM FULL** - сжимает таблицу, но может вызвать блокировку.
**autovacuum** автоматически выполняет эти операции в фоновом режиме.

Использование `VACUUM` и `ANALYZE` помогает поддерживать базу данных в оптимальном состоянии и улучшать 
производительность запросов.

Поговорим про PostgreSQL и команду cluster. Ниже мой список вопросов.
1. CLUSTER это блокирующая операция?
2. если я делаю выборку по индеку кластеризации без сортировки и с сортировкой есть ли разница по скорости фильтрации?
3. если я делаю выборку по индеку кластеризации а сортировку делаю по другому индексу который не является кластерным будет ли запрос оптимизирован?
3. если я выполнил клпстеризацию и после этого удалил одну запись это приведет к тому что следующая фильтрация будет работать медленно?
5. если я выполнил клпстеризацию и после этого добавил одну запись это приведет к тому что следующая фильтрация будет работать медленно?
