### Какие бывают индексы в Mysql?

1. **PRIMARY KEY** (первичный ключ)
   - Обеспечивает уникальность значений в колонке.
   - Автоматически создаётся индекс B-Tree.
   - Используется для идентификации каждой строки таблицы.
   - Может быть только один PRIMARY KEY на таблицу.
   - Не может быть NULL
2. **UNIQUE INDEX** (уникальный индекс)
   - Обеспечивает уникальность значений в колонке.
   - Позволяет несколько NULL значений (в отличие от PRIMARY KEY).
   - Можно использовать для проверки уникальности данных.
3. **INDEX** (обычный индекс)
   - Самый базовый тип индекса.
   - Ускоряет операции поиска и сортировки.
4. **FULLTEXT INDEX** (полнотекстовый индекс)
   - Используется для текстового поиска в больших текстовых полях.
   - Оптимизирован для поиска слов и фраз.
   - Поддерживается только в движках MyISAM, InnoDB (начиная с MySQL 5.6).
   - **Может ли быть NULL?**
5. **SPATIAL INDEX** (пространственный индекс)
   - Используется для работы с геоданными (геометрическими типами данных).
   - Применим для таблиц с движком MyISAM и InnoDB (MySQL 5.7 и выше).
   - Требуется, чтобы поле, на которое создаётся индекс, было объявлено как NOT NULL.
6. **COMPOSITE INDEX** (составной индекс)
   - Индекс, охватывающий несколько колонок.
   - Эффективен для запросов с фильтрацией по нескольким столбцам.
   - Порядок колонок в индексе имеет значение.
   - Важно: В запросах MySQL будет использоваться только та часть индекса, которая соответствует порядку колонок в запросе. Например, для WHERE customer_id = 1 AND product_id = 2 индекс работает полностью, а для WHERE product_id = 2 — нет.
7. **HASH INDEX** (хэш-индекс)
   - Используется только в таблицах с движком Memory.
   - Быстрее, чем B-Tree, при точном совпадении (=).
   - Не поддерживает диапазонные операции (<, >, BETWEEN).
8. **CLUSTERED INDEX** (кластерный индекс)
   - Присутствует только в таблицах с движком InnoDB.
   - Данные таблицы физически упорядочены по PRIMARY KEY или UNIQUE INDEX.
   - Если PRIMARY KEY отсутствует, MySQL создаёт скрытый кластерный индекс.
9. **FOREIGN KEY INDEX** (индекс внешнего ключа)
   - Автоматически создаётся при добавлении внешнего ключа (FOREIGN KEY).
   - Помогает поддерживать целостность данных между связанными таблицами.
10. **PREFIX KEY INDEX** (префикcный индекс)
   - Помогает оптимизировать запросы, использующих начальные части строки (например, `LIKE 'abc%'`)
   - Для создания используя синтаксис `CREATE INDEX ... ON ... (column(length))`
   - Для поиска используя оператор `LIKE` синтаксис `SELECT * FROM products WHERE name LIKE 'Smartphone%'`

### Вопросы:

1. PRIMARY KEY - может ли быть NULL?
   - Нет, значение PRIMARY KEY не может быть NULL. 
Это связано с его основным предназначением: уникально идентифицировать каждую строку в таблице. 
Все строки должны иметь значение для PRIMARY KEY, чтобы они могли быть однозначно найдены.
2. UNIQUE INDEX - выглядит как будто он может быть композитным UNIQUE COMPOSITE INDEX, есть ли такое понятие?
   - Да, UNIQUE COMPOSITE INDEX существует. Это индекс, который охватывает несколько колонок и требует 
   уникальности для комбинации их значений.
3. UNIQUE INDEX - Что если у меня в индексе одна колонка которая может быть NULL и я хочу создать 2 записи у которых значение NULL?
   - Вы можете создать несколько записей с NULL
   - NULL считается неопределённым значением и не нарушает ограничение уникальности.
   - NULL в MySQL не считается равным другому NULL.
4. INDEX - точно ли ускоряет процесс сортировки? Стоит ли избегать сортировку в запросе? Если ДА то в каких случаях?
   - Да, индекс ускоряет сортировку, так как данные в B-Tree хранятся в упорядоченном виде. 
   - Если запрос использует индексируемую колонку в ORDER BY, MySQL может использовать индекс для быстрой сортировки 
   т.к. он хранит данные в отсортированном виде.
   - Избегать сортировок стоит:
     - Если данных много и они не помещаются в оперативной памяти, MySQL временно записывает данные на диск для выполнения сортировки. Это сильно замедляет запрос.
     - Когда сортировка не критична для бизнес-логики.
     - Когда возможно отсортировать данные на уровне приложения.
     - Когда колонка не индексирована, что может привести к значительным задержкам.
     - Когда объём данных слишком велик.
     - Когда используется пагинация с глубокими смещениями. `SELECT * FROM orders ORDER BY created_at DESC LIMIT 100000, 10;` 
       Становятся медленными из-за сортировки и смещения. Лучше использовать "Keyset Pagination" вместо OFFSET.
5. FULLTEXT INDEX - Может ли быть NULL? На сколько он быстрый?
   - Колонки в FULLTEXT INDEX могут быть NULL.
   - FULLTEXT INDEX оптимизирован для полнотекстового поиска. Однако скорость зависит от объёма данных.
6. COMPOSITE INDEX - Можно ли сказать что это обычный индекс (INDEX) только имеет больше одной колонки или технически это совершенно разные индексы?
   - Технически COMPOSITE INDEX и обычный INDEX имеют схожий механизм работы (B-Tree)
   - COMPOSITE INDEX охватывает несколько колонок.
   - В запросах важен порядок колонок. Например, индекс `(A, B)` оптимален для `WHERE A = ? AND B = ?`, но не для `WHERE B = ?`
7. COMPOSITE INDEX - Отработает ли индекс и как для такого запроса WHERE customer_id = 1 если индекс по двум полям вот в такой очередности (INDEX idx_customer_product (customer_id, product_id))?
   - Да, COMPOSITE INDEX `(customer_id, product_id)` будет использоваться, так как `customer_id` стоит первым. 
   - Индекс всё равно полезен, хотя `product_id` в запросе не задействован.
8. PRIMARY KEY создает B-Tree - что такое B-Tree и как оно работает?
   - B-Tree — это структура данных, используемая для хранения индексов. 
     - Узлы дерева упорядочены. Это позволяет быстро искать данные и
     выполнять диапазонные запросы `(BETWEEN, <, >)`. Пример: для поиска числа `42`, 
     - B-Tree сначала проверяет корневой узел, затем следует по дереву, исключая ненужные диапазоны.
9. PRIMARY KEY - является уникальным индексом, если я создаю индекс (UNIQUE INDEX) по одной или нескольким колонкам то создается ли B-Tree?
   - Да, для UNIQUE INDEX используется структура B-Tree, чтобы обеспечить упорядоченность и проверку уникальности данных.
10. HASH INDEX почему он быстрее чем B-Tree?
    - HASH INDEX работает быстрее, так как хэш-функция напрямую вычисляет местоположение записи. 
    Это достигается благодаря тому, что хэш-функция сразу находит местоположение записи, не требуется обходить дерево или выполнять дополнительные сравнения.
    - Однако он эффективен только для точных сравнений (=) и не поддерживает диапазонные операции.
11. HASH INDEX что будет если я напишу выборку с (<, >, BETWEEN)?
    - HASH INDEX не поддерживает такие операции, и запросы с ними не используют этот индекс. База данных выполнит полное сканирование таблицы.
12. CLUSTERED INDEX - т.е. он создается автоматически при условиях отсутствия PRIMARY KEY, могу ли я создать его вручную?
    - Нет. В MySQL кластерный индекс создаётся автоматически на основе PRIMARY KEY. Если его нет, MySQL создаёт скрытый кластерный индекс.
13. CLUSTERED INDEX - как он работает и для чего он нужен?
    - Все строки таблицы физически хранятся в порядке, установленном кластерным индексом.
    - Когда вы вставляете строку в таблицу с кластерным индексом, MySQL ищет подходящее место в уже отсортированном наборе строк.
    - Если таблица не имеет PRIMARY KEY или UNIQUE INDEX, MySQL создаёт скрытый кластерный индекс, используя уникальный `ROW ID`.
    - В кластерном индексе данные таблицы физически хранятся в порядке ключа индекса. Однако, эти данные (строки таблицы) хранятся в листьях структуры B-Tree.
14. FOREIGN KEY INDEX - влияет ли этот индекс на скорость выборки данных? если да то как и при каких условиях? 
    - Однако его основная задача — поддерживать целостность данных НО:
      - MySQL при создании FOREIGN KEY например на колонку `customer_id`, автоматически создаёт INDEX на эту колонку, если он там еще не создан.
      - PostgreSQL при создании FOREIGN KEY например на колонку `customer_id` НЕ создаёт индекс автоматически. Чтобы ускорить выборку, INDEX нужно создать вручную.
15. Что такое B-Tree в Mysql?
    - B-Tree — основная структура индексов.
16. Движки Mysql - Memory, MyISAM, InnoDB - подробнее?
    - **InnoDB:**
        - **Особенности:** Поддерживает транзакции, внешние ключи, блокировку строк.
        - **Применение:** Большинство современных приложений (рекомендуется для критичных данных).
        - **Особенности индексов:** Использует Clustered Index для PRIMARY KEY.
    - **MyISAM:**
        - **Особенности:** Лёгкий и быстрый, но не поддерживает транзакции и внешние ключи.
        - **Применение:** Таблицы для чтения/записи без строгой консистентности.
        - **Особенности индексов:** Использует отдельный файл для хранения индексов.
    - **Memory:**
        - **Особенности:** Все данные хранятся в оперативной памяти (RAM). Очень быстро, но данные удаляются при перезапуске сервера.
        - **Применение:** Таблицы для временного хранения или кэша.
17. Есть ли разница на какой тип данных (число или строка) создается индекс например такие индексы как PRIMARY KEY, UNIQUE INDEX, INDEX, COMPOSITE INDEX? Как типы данных могут повлиять на скорость выборки?
    - Да, тип данных влияет:
      - Числовые индексы работают быстрее, так как их сравнение проще.
        - Для чисел сравнение сводится к простым операциям, таким как > или <, которые выполняются на уровне процессора.
        - Числа занимают фиксированное количество байт (например, INT — 4 байта, BIGINT — 8 байт), что делает их сравнение быстрым.
        - Сравнить два числа, такие как 123 и 456, можно за одну операцию.
      - Строковые индексы требуют больше времени, особенно если строки длинные.
        - Для строк необходимо сравнивать символы посимвольно до тех пор, пока не будет найдено различие или строка не закончится.
        - Строки имеют переменную длину, что добавляет дополнительные накладные расходы.
      - Используйте префиксные индексы для строк, чтобы уменьшить их размер: `CREATE INDEX idx_prefix ON users(email(10));`
    - Так же влияет на размер данных в индексе.
      - Числовые данные:
          - Занимают меньше места: например, INT занимает 4 байта.
          - Меньший размер данных позволяет хранить больше записей в одном узле B-Tree, уменьшая глубину дерева и ускоряя поиск.
      - Строковые данные:
          - Занимают больше места: например, строка длиной 255 символов может занимать до 255 байт (в зависимости от кодировки).
          - Индекс для строк требует больше места, что увеличивает глубину дерева и снижает производительность.

### PRIMARY KEY, INDEX, UNIQUE INDEX, COMPOSITE INDEX, (B-Tree).
```
                        [66, 133]
                       /    |    \
            [22, 44]    [88, 111]   [155, 177]
            /   |   \   /   |   \    /   |   \
  [1, 8] [15, 21] [30, 37] [45, 59] [67, 80] [89, 103] [112, 125] [134, 148] [156, 170] [178, 185] [193, 200]
    |        |         |         |          |           |            |           |            |            |
[1,2,3,4,5,6,7,8] ...                                                                          ... [193,194,195,196,197,198,199,200]
```
#### Что происходит при поиске индекса 4?
1. **Начинаем с корня: [66, 133]** - Сравниваем `4 < 66`, поэтому идем в левое поддерево.
2. **Переходим в узел: [22, 44]** - Сравниваем `4 < 22`, поэтому идем в левое поддерево.
3. **Переходим в узел: [1, 8]** - Сравниваем `4` и видим, что он лежит в диапазоне `1 – 8`.
4. **Идем в листовой узел:** - Листовой узел содержит все записи: `[1, 2, 3, 4, 5, 6, 7, 8]`.
5. **Находим запись:** - Извлекаем запись с индексом `4` напрямую из листового узла.

### HASH INDEX.
```
id | name
---|------
 1 | Alice
 2 | Bob
 3 | Carol
 
hash('1') -> указатель на строку с id = 1
hash('2') -> указатель на строку с id = 2
hash('3') -> указатель на строку с id = 3
```

1. **Ключ:** значение индекса (например, customer_id).
2. **Значение:** ссылка на соответствующую строку в таблице.

### FULLTEXT INDEX.
```
id | content
---|-----------------
 1 | "Hello world"
 2 | "World of code"
 3 | "Hello code"

"Hello" -> [1, 3]    // Слово "Hello" встречается в записях 1 и 3.
"world" -> [1, 2]    // Слово "world" встречается в записях 1 и 2.
"code"  -> [2, 3]    // Слово "code" встречается в записях 2 и 3.
```

1. Разбивает текст на слова (токены).
2. Создает список слов и их позиций в документах.

### SPATIAL INDEX (R-Tree).
```
id | location
---|-----------------
 1 | POINT(1, 1)
 2 | POINT(5, 5)
 3 | POINT(10, 10)
 4 | POINT(20, 20)
 
               [0, 25] x [0, 25]
                /            \
    [0, 10] x [0, 10]   [15, 25] x [15, 25]
      /          \              \
 POINT(1, 1)  POINT(5, 5)    POINT(20, 20)
                      \
                   POINT(10, 10)
```

### Что такое Keyset Pagination?

**Keyset Pagination** — это метод постраничной навигации (пагинации), который использует уникальный ключ 
(например, PRIMARY KEY или другой индексированный столбец) для получения следующей страницы данных. 
Этот подход обеспечивает быструю и эффективную работу с большими наборами данных, избегая недостатков 
традиционной пагинации с OFFSET.

**Пример**
```
| id  | name       | created_at         |
|-----|------------|--------------------|
| 1   | Alice      | 2023-01-01 10:00  |
| 2   | Bob        | 2023-01-02 11:00  |
| 3   | Charlie    | 2023-01-03 12:00  |
| 4   | David      | 2023-01-04 13:00  |
| 5   | Eve        | 2023-01-05 14:00  |
```

**Пример получения первой страницы:**
```sql
SELECT * FROM users
ORDER BY id ASC
LIMIT 3;
```

**Пример получения следующей страницы:**
Для получения следующей страницы используем id > 3 (последнее значение из предыдущего результата):
```sql
SELECT * FROM users
WHERE id > 3
ORDER BY id ASC
LIMIT 3;
```

### Как работает OFFSET?
Запрос с `OFFSET` указывает базе данных пропустить указанное количество строк перед возвратом результата.
```sql 
SELECT * FROM users ORDER BY id ASC LIMIT 3 OFFSET 100000;
```

**Проблема:**

База данных читает все 100000 строк когда нужно только 3 строки.

1. Чтобы выполнить запрос с `ORDER BY`, база данных должна получить все строки и отсортировать их.
2. Если столбец `id` индексирован, сортировка выполняется быстрее, так как база данных использует индекс. 
Но даже в этом случае база данных должна обработать `100,003` строки, чтобы извлечь нужные данные.
3. После сортировки база данных должна "пропустить" первые `100,000` строк, чтобы дойти до интересующих строк.
Для этого требуется последовательное чтение, чтобы понять, какие строки "пропустить".
4. Чем больше `OFFSET`, тем больше данных нужно обработать.

