[Назад](../README.md)

### Перечислите основные меры безопасности, такие как защита от XSS, CSRF и использование helmet.

1. Защита от XSS (Cross-Site Scripting) - это уязвимость, при которой злоумышленник может внедрить вредоносный скрипт 
на веб-страницу.
   - Очистка пользовательского ввода (Escape HTML) - Любой ввод, который должен быть отображен как текст в HTML, 
   должен быть экранирован — специальные символы должны заменяться на безопасные HTML-коды.
    ```javascript
    // Пример ручного экранирования:
    function escapeHtml(input) {
        return input
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
    escapeHtml("<script>alert('XSS')</script")
    ```
    ```javascript
    // Пример использования сторонней библиотеки DOMPurify:
    const DOMPurify = require('dompurify')
    DOMPurify.sanitize("<script>alert('XSS')</script")
    ```
   - Дополнительным слоем защиты является использование заголовка Content Security Policy (CSP), который ограничивает 
    выполнение JavaScript на страницах.
    ```javascript
    // Пример добавления CSP с помощью helmet.
    // Этот заголовок запрещает выполнение скриптов с любых источников, кроме тех, что указаны в scriptSrc.
    const helmet = require('helmet')
    app.use(helmet.contentSecurityPolicy({
        directives: {
            defaultSrc: ["'self'"],
            scriptSrc: ["'self'", "trusted-source.com"]
        }
    }))
    ```
2. Защита от CSRF (Cross-Site Request Forgery) - это атака, при которой злоумышленник заставляет браузер жертвы 
выполнять нежелательные действия на сайте.
   - Использование CSRF-токенов, которые добавляются в формы и проверяются сервером при каждом запросе.
   - Проверка источника запроса (например, с помощью заголовка Origin или Referer).
   - Использование метода SameSite для cookie, чтобы предотвратить их отправку с внешних сайтов.
     - **SameSite=Strict:** Cookies отправляются только при прямом взаимодействии с сайтом (например, при навигации по 
     самому сайту). Они не будут отправляться при переходе с другого домена или при загрузке ресурсов с другого домена.
     - **SameSite=Lax:** Cookies отправляются при навигации с другого домена только для "безопасных" методов HTTP 
     (GET, HEAD), но не для POST, PUT и других.
     - **SameSite=None:** Cookies отправляются при любых кросс-доменных запросах, но это требует наличия атрибута 
     Secure, чтобы cookie передавалась только по HTTPS.
3. Защита от SQL-инъекций
    - Параметризованные запросы: Это самый эффективный способ предотвращения SQL-инъекций. Вместо вставки данных 
    напрямую в запрос, используйте placeholders (плейсхолдеры), а параметры передавайте отдельно.
    - Использование ORM (Object-Relational Mapping): ORM-библиотеки, Sequelize или Mongoose (для MongoDB), автоматически 
    экранируют пользовательский ввод и используют параметризованные запросы под капотом. Это уменьшает риск SQL-инъекций, 
   так как запросы строятся через методы, а не с помощью конкатенации строк.
    - Экранирование пользовательского ввода: Если невозможно использовать параметризованные запросы, можно экранировать 
   пользовательский ввод. Это включает в себя замену специальных символов, которые могут быть использованы для 
   SQL-инъекций.
    - Ограничение прав доступа к базе данных: Дайте минимально необходимые права для учетной записи базы данных, 
    которую использует ваше приложение. Это уменьшает вероятность серьезных последствий в случае успешной SQL-инъекции.
    - Проверка и валидация пользовательского ввода: Всегда проверяйте и валидируйте пользовательский ввод перед тем, 
    как использовать его в запросах. Убедитесь, что данные имеют ожидаемый формат, и отклоняйте все подозрительные или некорректные данные. Например, если ожидается числовое значение, проверьте, что оно действительно является числом.
4. Использование HTTPS
5. Ограничение частоты запросов (Rate Limiting)
   - Мониторинг запросов:
     - Сервер отслеживает количество запросов, поступающих от каждого клиента (например, по IP-адресу).
     - Вся информация о частоте запросов хранится в памяти сервера или в кэширующем сервисе, таком как Redis.
   - Ограничение количества запросов:
     - Устанавливается лимит на количество запросов, которые клиент может отправить в течение заданного времени 
     (например, 100 запросов за 10 минут).
     - Если клиент превышает этот лимит, сервер блокирует дополнительные запросы или возвращает ошибку (например, 
     HTTP статус 429 "Too Many Requests").
   - Сброс счетчика запросов:
     - Лимит запросов сбрасывается после истечения заданного интервала времени, и клиент снова может отправлять запросы.


### Основные элементы работы HTTPS
1. Шифрование данных:
    - Что это такое: Все данные, передаваемые между клиентом и сервером, шифруются, чтобы предотвратить их перехват и 
    чтение злоумышленниками.
    - Как это работает: При установлении соединения браузер и сервер обмениваются криптографическими ключами. Данные, 
    отправляемые по сети, шифруются этими ключами, что делает их нечитаемыми для третьих лиц.
    - Пример: Пароль пользователя, переданный через HTTPS, будет зашифрован и не сможет быть перехвачен в читаемом 
    виде злоумышленником.
2. Аутентификация:
   - Что это такое: Аутентификация подтверждает подлинность сервера, с которым общается клиент, чтобы избежать атак 
   «человек посередине» (MitM).
   - Как это работает: Сервер предоставляет клиенту SSL/TLS-сертификат, который подписан сертификационным центром (CA). 
   Браузер проверяет этот сертификат, чтобы убедиться, что он принадлежит именно тому серверу, на который направлен 
   запрос.
   - Пример: При подключении к банку по HTTPS браузер проверяет, что сертификат принадлежит именно этому банку, а 
   не мошенническому серверу.
3. Целостность данных:
   - Что это такое: HTTPS гарантирует, что данные не были изменены при передаче.
   - Как это работает: При передаче данных используется контрольная сумма (хеш), которая проверяет, что данные не были 
   изменены на пути между клиентом и сервером.
   - Пример: Злоумышленник не сможет изменить содержимое веб-страницы или ответ сервера на пути к клиенту, так как 
   любое изменение данных нарушит контрольную сумму, и браузер обнаружит подделку.