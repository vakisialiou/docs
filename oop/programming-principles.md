[Назад](./basic.md)

### DRY (Don't Repeat Yourself)

Любой фрагмент информации или логики в коде должен существовать в одном месте, а не дублироваться.

**Плохой пример:**

```javascript
// Нарушение DRY
if (weight > 50) {
    console.log("Требуется дополнительная плата за вес")
}

// В другом месте
if (weight > 50) {
    console.log("Требуется дополнительная плата за вес")
}
```

**Хороший пример:**

```javascript
function checkWeightSurcharge(weight) {
    if (weight > 50) {
        console.log("Требуется дополнительная плата за вес")
    }
}

// Использование функции
checkWeightSurcharge(weight)
```

Если понадобится изменить правило проверки веса, это можно сделать в одном месте, и все части приложения будут 
следовать новым правилам.

### KISS (Keep It Simple, Stupid)

Системы и решения должны быть максимально простыми и понятными. Этот принцип предполагает, что сложные решения 
должны применяться только в случае реальной необходимости. Лаконичность и простота делают код более доступным 
для понимания и поддержки.

#### Основные идеи KISS:

- **Простота в дизайне:** Программа должна быть разработана таким образом, чтобы каждый её элемент был легко 
объясним и понятен. Усложнение архитектуры, добавление ненужных абстракций или избыточного кода приводит к тому, 
что система становится трудной для понимания и дальнейшей поддержки.
- **Избегание чрезмерной абстракции:** Иногда разработчики стремятся сделать код более **«гибким»** или 
**«универсальным»**, добавляя сложные структуры и абстракции, которые на деле могут оказаться ненужными. `KISS` 
предлагает избегать этого, пока не станет очевидно, что такие решения действительно необходимы.
- **Поддержка легкости изменений:** Простые решения легче модифицировать. Когда код не перегружен сложными 
зависимостями и абстракциями, его проще адаптировать к изменяющимся требованиям.
- **Прозрачность кода:** `KISS` ориентирован на то, чтобы другие разработчики могли быстро разобраться в коде без 
необходимости тратить много времени на его изучение. Это улучшает командную работу и ускоряет разработку.

**Плохой пример:** - Задача, вывести в консоль «Hello, World». Нарушение принципа KISS может выглядеть так:

```javascript
class HelloWorldPrinter {
    constructor(language) {
        this.language = language
    }

    getGreeting() {
        switch(this.language) {
            case 'en':
                return 'Hello, World!'
            case 'es':
                return '¡Hola, Mundo!'
            default:
                return 'Hello, World!'
        }
    }

    printGreeting() {
        console.log(this.getGreeting())
    }
}

const printer = new HelloWorldPrinter('en')
printer.printGreeting()
```

Этот код слишком усложнён для простой задачи. В нём используется класс, переключатель на языки, хотя цель — всего лишь 
вывести **«Hello, World»**. Подобная сложность не оправдана.

**Хороший пример:**

```javascript
function printHelloWorld() {
  console.log('Hello, World!')
}

printHelloWorld()
```

Этот вариант легче понять, поддерживать и расширять, если потребуется. Нет излишней абстракции, логика ясна, и код решает 
задачу без ненужных конструкций.

### YAGNI (You Aren't Gonna Need It)

Не стоит реализовывать функциональность заранее, исходя из предположений о том, что она может понадобиться в будущем. 
Принцип гласит, что нужно писать только тот код, который необходим сейчас, а не пытаться предсказать будущие требования и 
добавлять избыточные функции.

#### Основные идеи:

1. **Разработка по реальным требованиям:** Вместо того чтобы добавлять функциональность на случай, если она понадобится в 
будущем, YAGNI предлагает фокусироваться на текущих задачах. Это помогает сократить избыточную сложность и не тратить время 
на поддержку кода, который может никогда не понадобиться.
2. **Снижение сложности кода:** Заблаговременное добавление лишних функций приводит к усложнению системы, увеличивает 
количество зависимостей и точек возможных ошибок. Простота важна для поддерживаемости, и YAGNI помогает избежать ненужных 
усложнений.
3. **Экономия ресурсов:** Реализация лишних функций требует времени и ресурсов, но при этом может оказаться бесполезной. 
Принцип `YAGNI` помогает сэкономить время на разработку, тестирование и поддержку, а также уменьшить количество потенциальных 
багов.
4. **Поддержка гибкости:** Выполнение работы "по мере необходимости" способствует созданию гибкого кода, который легче 
модифицировать. Реализация ненужных функций может сделать систему менее гибкой и более громоздкой для будущих изменений.

### SoC (Separation of Concerns)

Это принцип программирования, который подразумевает разделение кода на логически независимые части, каждая из которых отвечает 
за выполнение своей конкретной задачи. Главная цель этого подхода — сделать систему более модульной, проще в поддержке и 
масштабировании. Когда каждый модуль фокусируется только на своей «заботе» (`concern`), код становится чище, более 
организованным и легко модифицируемым.

#### Основные идеи:

1. **Модульность:** Каждый модуль или часть системы должна быть автономной и отвечать за свою область ответственности. Это 
позволяет изменять одну часть системы, не затрагивая другие, что уменьшает вероятность ошибок и облегчает внесение изменений.
2. **Четкая ответственность:** Код, который объединяет разные обязанности в одном месте, становится сложным для понимания и 
поддержки. SoC подразумевает, что каждая часть системы должна быть ответственна за выполнение своей функции.
3. **Переиспользуемость:** Когда код разделен на четкие и независимые части, его можно переиспользовать в других контекстах. 
Например, если отдельная часть отвечает за валидацию данных, ее можно легко использовать в других проектах или модулях.
4. **Упрощение изменений:** Когда система структурирована по SoC, изменения в одной части не требуют изменений в других, так 
как каждая часть изолирована и управляет только своей задачей.

**Плохой пример:**

```javascript
// Нарушение SoC: вся логика в одном месте
function handleRequest(req, res) {
    // Получение данных из базы данных
    const user = database.query(`SELECT * FROM users WHERE id = ${req.params.id}`)
    
    // Валидация данных
    if (!user) {
        res.status(404).send("User not found")
        return
    }
    
    // Формирование HTML
    const html = `<html>
        <head><title>User Info</title></head>
        <body>
            <h1>${user.name}</h1>
            <p>Email: ${user.email}</p>
        </body>
    </html>`
    
    res.send(html)
}
```

В этом примере одна функция решает сразу несколько задач:

- Доступ к базе данных
- Валидация данных
- Формирование HTML-ответа

**Хороший пример:**

```javascript
// Логика для работы с базой данных
function getUserById(userId) {
    return database.query(`SELECT * FROM users WHERE id = ${userId}`)
}

// Логика для валидации данных
function validateUser(user) {
    if (!user) {
        throw new Error("User not found")
    }
}

// Логика для рендеринга HTML
function renderUserPage(user) {
    return `<html>
        <head><title>User Info</title></head>
        <body>
            <h1>${user.name}</h1>
            <p>Email: ${user.email}</p>
        </body>
    </html>`
}

// Обработчик HTTP-запроса
function handleRequest(req, res) {
    try {
        const user = getUserById(req.params.id)
        validateUser(user)
        const html = renderUserPage(user)
        res.send(html)
    } catch (error) {
        res.status(404).send(error.message)
    }
}
```
