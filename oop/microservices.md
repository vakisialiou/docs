
### Паттерн API Gateway

Это важный паттерн в архитектуре микросервисов, который представляет собой единый входной точечный интерфейс для 
всех клиентских запросов к системе микросервисов. Он служит прокси-сервером, принимающим запросы от клиентов и 
перенаправляющим их на соответствующие микросервисы, а также может выполнять дополнительные задачи, такие как 
аутентификация, балансировка нагрузки, кэширование и мониторинг.

#### Основные задачи API Gateway:

- **Маршрутизация запросов:** API Gateway принимает входящие запросы и перенаправляет их на нужные микросервисы.
- **Аутентификация и авторизация:** Обеспечивает безопасность, проверяя токены доступа или авторизуя пользователей.
- **Агрегация данных:** Если для выполнения одного клиентского запроса требуется информация из нескольких микросервисов, 
API Gateway может объединить ответы и вернуть клиенту единый результат.
- **Кэширование:** Может кэшировать ответы для улучшения производительности.
- **Трансформация запросов и ответов:** Преобразует запросы и ответы для удобства работы клиентов с различными форматами 
данных.
- **Мониторинг и логирование:** Собирает метрики и логи для анализа трафика и производительности микросервисов.

#### Пример:

Предположим, клиент хочет получить информацию о заказе и связанной с ним информации о продукте и пользователе. 
API Gateway принимает один запрос от клиента, распределяет его по нужным сервисам, собирает результаты и возвращает 
объединённый ответ.

Получение полной информации о заказе с деталями пользователя и продукта:
```plaintext
GET http://localhost:3000/orders/1/details
```

Получение данных о заказе:
```plaintext
GET http://localhost:3000/orders/1
```

Получение данных о пользователе:
```plaintext
GET http://localhost:3001/users/1
```

Получение информации о продукте:
```plaintext
GET http://localhost:3002/products/1
```

### Паттерн Saga

Это паттерн управления распределёнными транзакциями, который используется в микросервисной архитектуре. В отличие от 
традиционных монолитных приложений, где транзакции могут быть атомарными (ACID), в микросервисах каждая операция, 
входящая в состав одной логической транзакции, выполняется в разных сервисах. Паттерн `Saga` помогает управлять такими 
распределёнными транзакциями, обеспечивая их согласованность.

`Saga` представляет собой цепочку действий, в которой каждая операция микросервиса является транзакцией, и если одна из 
операций завершается с ошибкой, `Saga` инициирует компенсирующие действия (`rollback`) для каждой завершённой операции. 
Это позволяет избежать частичной успешной транзакции, когда часть системы изменилась, а другая — нет.

#### Сценарии работы Saga:

1. **Оркестрация:** Центральный контроллер (`Saga orchestrator`) управляет последовательностью действий, запуская операции 
и отслеживая их завершение. Если одна из операций завершается неудачно, `orchestrator` вызывает компенсирующие транзакции 
для отката изменений.
2. **Хореография:** Каждый микросервис сам решает, что делать после завершения своей операции, оповещая другие сервисы о 
своем результате. В случае неудачи каждый сервис инициирует компенсирующую транзакцию.

#### Пример:

Предположим, что у нас есть система заказа товаров, состоящая из нескольких микросервисов:

- **Order Service** — создаёт заказ.
- **Payment Service** — обрабатывает платёж.
- **Inventory Service** — резервирует товар на складе.
- **Shipping Service** — организует доставку.

#### Пример реализации через оркестрацию:

```javascript
class SagaOrchestrator {
  async executeOrderSaga(orderDetails) {
    try {
      // Шаг 1: Создание заказа
      await orderService.createOrder(orderDetails)
      
      // Шаг 2: Обработка платежа
      await paymentService.processPayment(orderDetails.paymentInfo)
      
      // Шаг 3: Резервирование товара
      await inventoryService.reserveProduct(orderDetails.productId)
      
      // Шаг 4: Организация доставки
      await shippingService.shipOrder(orderDetails.shippingInfo)

      console.log("Заказ успешно выполнен.")
    } catch (error) {
      console.error("Ошибка во время выполнения Saga:", error)
      // Компенсационные действия
      await this.compensateOrderSaga(orderDetails)
    }
  }

  async compensateOrderSaga(orderDetails) {
    // Отмена доставки, если уже начата
    await shippingService.cancelShipment(orderDetails.orderId)

    // Возврат товара на склад
    await inventoryService.releaseProduct(orderDetails.productId)

    // Отмена платежа
    await paymentService.refundPayment(orderDetails.paymentInfo)

    // Отмена заказа
    await orderService.cancelOrder(orderDetails.orderId)

    console.log("Компенсация завершена. Заказ отменен.")
  }
}

const sagaOrchestrator = new SagaOrchestrator()
sagaOrchestrator.executeOrderSaga(orderDetails)
```

**SagaOrchestrator** - Управляет последовательностью шагов и инициирует компенсирующие действия при 
возникновении ошибок.

#### Пример реализации через хореографию:

Паттерн `Saga` в микросервисной архитектуре часто реализуется с помощью систем обмена сообщениями по типу `Pub/Sub`, 
где один сервис публикует событие, а другие сервисы подписаны на эти события и реагируют на них. Такая реализация 
позволяет сохранить гибкость и независимость микросервисов.

1. **Order Service** создаёт заказ и отправляет событие `OrderCreated`.
2. **Payment Service** реагирует на событие `OrderCreated` и обрабатывает платёж, затем отправляет событие `PaymentProcessed`.
3. **Inventory Service** реагирует на событие `PaymentProcessed` и резервирует товар, затем отправляет событие `ProductReserved`.
4. **Shipping Service** реагирует на событие `ProductReserved` и организует доставку.

Если один из сервисов не справляется, он сам инициирует компенсирующее событие, например, если **Shipping Service** не может 
организовать доставку, он отправляет событие `ShippingFailed`, на которое другие сервисы реагируют откатом своих операций.
