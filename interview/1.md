
1. Знание языка JavaScript/Typescript
2. Алгоритмы, структуры данных
3. Реляционные базы данных
4. Нереляционные базы данных
5. Сети
6. Solution Design


1. Programming Languages (JavaScript/Typescript)
   - data types
   - var / let / const
   - class functions vs arrow functions
   - abstract class vs interface
   - unknown ns any
   - expressjs vs nestjs
   - js difference between Node.js and browser
2. Node.js
   - main parts in Node.js
   - event loop
   - multithreading in Node.js
3. DBs
   - SQL
     - indexes
     - transaction isolation level
   - NoSQL
     - hash-index
4. Network
   - HTTP
   - HTTPS
   - TCP vs UDP
   - caching techniques
   - DNS
5. Solution Design
   - rate limiter 
6. CSS
   - Selectors, selector specificity, how the browser reads `.wrap .header div`.
   - Box Model, what does it consist of? Tell me about `box-sizing`.
   - What is the difference between flex and grid? How do they work?
7. React
   - hooks vs classes react
   - hooks rules
   - `useEffect` vs `useLayoutEffect`
   - SSR in react
8. Browser
   - connection between website and frame
   - critical Rendering Path (CRP) - what it is, optimization methods
     - File Concatenation
     - Image Sprites
     - Resource minification and compression, code minification
     - Image Compression IMG: loading="lazy"
     - Script: async or deffer inline. Critical Image Formats: JPEG, PNG, WebP
     - Responsiveness: Specify width and height for images to unnecessary layout recalculations.
     - HTTP Caching


#### Programming Languages (JavaScript/Typescript)
1. data types JavaScript
   - `number` – числа (целые и с плавающей точкой)
   - `string` – строки (текст)
   - `boolean` – логический тип (true / false)
   - `null` - отсутствие значения (задается явно)
   - `undefined` - переменная объявлена, но не имеет значения
   - `symbol` - уникальный идентификатор (редко используется)
   - `bigint` - числа больше, чем Number.MAX_SAFE_INTEGER
   - `object` - сложный тип данных, который может хранить коллекции значений и более сложные сущности.
2. data types Typescript
   - `any` – отключает проверку типов
   - `unknown` – безопасная альтернатива `any`
   - `void` – используется для функций, которые ничего не возвращают
   - `never` – значение, которое никогда не будет возвращено
   - `tuple` – массив с фиксированным количеством элементов
   - `enum` – перечисления
3. `any` vs `unknown`
   - Тип `any` позволяет присваивать переменной любое значение и использовать её без ограничений. 
   TypeScript не будет проверять, правильно ли ты работаешь с этим значением.
   - Тип `unknown` тоже может хранить любое значение, но в отличие от `any`, перед использованием этого 
   значения TypeScript требует проверить его тип.
4. `void` и `never`
   - Тип `void` используется в функциях, которые ничего не возвращают.
   - ип `never` используется в функциях, которые никогда не заканчиваются корректно. Это могут быть функции, 
   выбрасывающие исключения (throw) или бесконечные циклы.
5. `var` / `let` / `const`
   1. Область видимости (Scope)
      - `var` – функция (Function Scope)
      - `let` и `const` – блок (Block Scope)
      - `var` доступен во всей функции, а `let` и `const` только в своем блоке (`if`, `{}`).
   2. Поднятие (Hoisting)
      - `var` можно использовать до объявления, но оно будет `undefined`.
      - `let` и `const` использование до объявления вызовет ошибку.
   3. Перезапись и изменение значений
      - `var` – можно изменять и переобъявлять.
      - `let` – можно изменять, но нельзя переобъявлять.
      - `const` – нельзя изменять и нельзя переобъявлять.
   4. Поведение в глобальной области (`window` в браузере)
      - `var` становится свойством `window`
      - `let` и `const` не добавляются в `window`.
6. `class functions` vs `arrow functions`
   - `this` – ключевое различие
   - `class function` 
     - `this` зависит от контекста вызова.
     - методы класса хранятся в `prototype`
     - В методах класса можно использовать `super` для вызова методов родителя.
   - `arrow functions`
     - `this` фиксируется в момент создания и не меняется.
     - стрелочные функции определяются как свойства класса и не добавляются в `prototype`
     - в стрелочных функциях `super` не работает.
7. `abstract class` vs `interface`
   - `interface`
     - описывает только структуру, не содержит реализацию.
     - не компилируется в JavaScript – интерфейсы нужны только на этапе TypeScript
     - может содержать только методы и свойства без реализации.
   - `abstract class`
     - это класс с частичной реализацией, от которого можно наследоваться.
     - может содержать как реализованные, так и абстрактные (без реализации) методы.
     - компилируется в JavaScript
8. `interface` vs `type`
   - `interface`
     - Поддерживает наследование (`extends`)
     - Не может описывать примитивные типы (`string`, `number` и т. д.)
     - Лучше подходит для OOP
   - `type`
     - Используется для любых типов – объектов, примитивов
     - Нельзя расширять через `extends`, но можно комбинировать (& и |)
9. `expressjs` vs `nestjs`
   - `Express.js`
     - Это минималистичный фреймворк
     - Предоставляет только базовые функции для работы с HTTP-запросами.
     - Позволяет строить сервер с нуля, добавляя нужные библиотеки (например, `express-session`, `cors`)
     - Не навязывает архитектуру.
   - `Nest.js`
     - Готовая архитектура (модули, контроллеры, сервисы, DI).
     - Поддержка TypeScript и декораторов.
     - Встроенные механизмы аутентификации, валидации, логирования.
     - Работает с WebSockets, GraphQL, и микросервисами "из коробки".
10. `Dependency Injection (DI)` vs `Dependency Inversion Principle (DIP)` 
    - `(DI)` - это паттерн, который помогает внедрять зависимости и следовать DIP.
    - `(DIP)` - это принцип проектирования. 
    ```js
      class Database {
        query(sql: string) {
            console.log('Executing SQL');
        }
      }
      
      class UserService {
        private db: Database;
      
        constructor(db: Database) {
            this.db = db; // ✅ Зависимость передается извне
        }
        
        getUser(id: number) {
            this.db.query(`SELECT * FROM users WHERE id = ${id}`);
        }
      }
      
      // Передаем зависимость при создании
      const db = new Database();
      const userService = new UserService(db);
      userService.getUser(1);
    ```
11. JS difference between Node.js and browser
    - Среда выполнения
    - Доступ к API
    - Node.js
      - Встроенные модули (`fs`, `http`, `path`, `os`).
      - Нет доступа к DOM (Document Object Model) или браузерным API, таким как `window`, `document`, `localStorage`.
      - `Event Loop` отличается, т.к. не обрабатывает события пользовательского интерфейса.
    - Браузер
      - Имеет доступ к DOM (`window`, `document`, `localStorage`)
      - Имеет события пользовательского интерфейса
      - `Event Loop` реагирует на события пользовательского интерфейса.
12. Main parts in Node.js
    - Event Loop - Это механизм, который позволяет Node.js выполнять асинхронные операции, 
    не блокируя основной поток.
    - Libuv - Библиотека, которая используется Node.js для работы с асинхронными операциями 
    на уровне операционной системы. Использует пул потоков для выполнения тяжёлых задач.
    - V8 JavaScript Engine
      - Парсинг: V8 сначала анализирует JavaScript-код, преобразуя его в абстрактное синтаксическое дерево (AST). 
      - Компиляция: Затем V8 компилирует AST в машинный код. 
      - Оптимизация: V8 использует различные техники оптимизации. Например: сборка мусора, анализирует выполняемый код 
      и оптимизирует его на лету.
    - Node.js API - Это набор встроенных модулей, которые предоставляют функциональность для работы с системными ресурсами.
    - NPM
    - Streams - это абстракция для работы с данными, которые обрабатываются по частям.
    - Cluster Module - Модуль для распределения нагрузки между несколькими процессами.
    - Workers - Это механизм для выполнения параллельных операций в фоновом режиме, без блокировки основного потока.
13. [event loop](./../node/event-loop.md)
14. `multithreading` in Node.js
    - Node.js по умолчанию работает в одном потоке, но это не означает, что он не может обрабатывать несколько задач 
    одновременно. Это достигается через неблокирующие асинхронные операции.
    - Для работы с многозадачностью Node.js использует библиотеку `libuv` которая выполнять асинхронные операции через 
    пул потоков.
    - Модули `cluster` || `pm2` - позволяют создавать несколько экземпляров Node.js, каждый из которых работает в 
    своем отдельном процессе. Эти процессы могут быть распределяться между ядрами многопроцессорных серверов.
    - `Worker Threads` - позволяет выполнять тяжелые вычисления в отдельных потоках.
    - `Child Processes` - позволяют запускать внешние программы или скрипты в отдельных процессах.
    - `Docker` & `Nginx` - Можно поднять несколько докер образов на каждый процессор и использовать балансер `Nginx`
15. [transaction isolation level](./../db/transactions.md)
    - уровни
      - READ UNCOMMITTED - Чтение незавершенных данных
      - READ COMMITTED - Чтение подтвержденных данных
      - REPEATABLE READ - Повторяемое чтение
      - SERIALIZABLE - Сериальный
    - возможные решения
      - выбор правильного уровня изоляции
      - использовать временную метку или версию
      - использование очередей сообщений
      - распределенные транзакции с использованием таких паттернов как `saga`
16. `hash-index` (Redis, MongoDB, Mysql Memory Engine)
    - это структура данных, которая используется для быстрого поиска значений.
    - индекс обычно хранится в виде хеш-таблицы, где хеш-значение используется для вычисления позиции данных в 
    памяти или на диске. 
    - неэффективен для диапазонных запросов
    - неэффективность при частых обновлениях данных - если база данных часто обновляется, хеш-индексы могут 
    требовать частых перерасчетов хешей и перемещения данных, что также может снизить производительность.
17. [Network](./../network/base.md)

#### Solution Design

Rate Limiter - это механизм, который ограничивает количество запросов к системе за определенный 
промежуток времени. Это помогает:
- Защититься от DDoS-атак
- Предотвратить перегрузку сервера
- Ограничить злоупотребление API (например, бесплатными пользователями)

1. Token Bucket - Ведро с токенами. 
   - Каждую секунду добавляется N токенов
   - Если токены кончились, то запросы блокируются.
2. Leaky Bucket - Протекающее ведро. 
   - запросы помещаются в очередь 
   - если очередь переполнена — лишние запросы отбрасываются.
3. Fixed Window - Фиксированное окно 
   - Каждому пользователю дается N запросов в минуту. 
   - Если лимит превышен, запросы блокируются.
4. Sliding Window - Скользящее окно
   - учитывает запросы за последние X секунд.
   - Если лимит превышен, запросы блокируются.

Где хранить данные о лимитах?
- В памяти (In-Memory) - Быстро, но не распределяется между серверами.
- В Redis - Работает в кластерных и распределенных системах. Можно хранить счетчик с TTL (EXPIRE).
- В БД - Медленно, но надежно

#### CSS
1. Selectors, selector specificity, how the browser reads `.wrap .header div`.

   Браузер читает селекторы справа налево:
   1. Ищет все <div>.
   2. Фильтрует те, которые внутри .header.
   3. Фильтрует .header, которые находятся внутри .wrap.
  
2. Box Model, what does it consist of? Tell me about `box-sizing`.

   Box Model определяет, как элементы устроены и как рассчитывается их размер на веб-странице.
   ```
   | Margin  |  (Внешнее пространство)
   | Border  |  (Граница)
   | Padding |  (Внутренний отступ)
   | Content |  (Текст, изображение и т.д.)
   ```
   
   Расчет общего размера (по умолчанию box-sizing)
   - Ширина содержимого (Content width) = 200px
   - Отступы (Padding) = 20px с каждой стороны → 40px (суммарно)
   - Границы (Border) = 5px с каждой стороны → 10px (суммарно)
   - Общий размер (включая padding и border) = 200px (содержимое) + 40px (отступы) + 10px (граница) = 250px

   `box-sizing` – это CSS-свойство, которое определяет, как рассчитывается размер элемента. Оно влияет на то, 
   включаются ли отступы и границы в общую ширину и высоту элемента.
    - `box-sizing: content-box;` (по умолчанию) - если у вас есть элемент с шириной 200px, и вы добавляете 
   отступы и границы, общий размер будет больше 200px.
    - `box-sizing: border-box;` - это означает, что отступы и границы включаются в эти 200px, и общий размер 
   не увеличивается.

3. What is the difference between flex and grid? How do they work?
   - Flexbox и CSS Grid — это два разных подхода для создания макетов в CSS.
   - Flexbox (одномерная модель макета) — распределяет элементы вдоль одной оси (горизонтальной или вертикальной).
   - Grid (двумерная модель макета) - позволяет управлять как строками, так и колонками.
