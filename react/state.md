### В чем разница между state и props?
- State — это внутреннее состояние компонента, которое может изменяться и перерендеривать компонент.
- Props — это данные, передаваемые от родительского компонента к дочернему. Компоненты не могут изменять свои props.
### Как изменяется state? Как работает setState?
- Классовые компоненты (this.setState)
  - Инициализация в конструкторе.
  - В классовых компонентах один состояние на весь компонент. 
  - В классовых компонентах вызов this.setState() объединяет изменения с текущим состоянием.
  - Это значит, что если вы обновляете только часть состояния, другие свойства состояния сохраняются.
- Функциональные компоненты (useState)
  - Инициализация прямо внутри компонента с помощью useState.
  - У компонента может быть N кол-во useState.
  - В функциональных компонентах при вызове setState состояние перезаписывается полностью.
  - Если состояние было объектом, вам нужно вручную сохранять другие его свойства при обновлении.

Оба метода обновляют состояние **асинхронно**, и для корректного обновления на основе предыдущего состояния лучше 
использовать функциональный синтаксис.

### Что произойдет, если вызвать setState несколько раз подряд?
Если вызвать setState или this.setState несколько раз подряд, React не будет немедленно обновлять состояние после 
каждого вызова. Вместо этого он объединяет (batch) эти вызовы для повышения производительности, чтобы избежать лишних 
перерендеров компонента.

**Пример для классового компонента 1:**
```javascript
this.setState({ count: this.state.count + 1 });
this.setState({ count: this.state.count + 1 });
this.setState({ count: this.state.count + 1 });
```

В этом случае, несмотря на три вызова setState, состояние может измениться только один раз, так как все вызовы могут 
быть объединены. В результате, если ``count`` было, например ``0`` то после трех вызовов setState значение станет ``1``

**Пример для классового компонента 2:**
```javascript
const a = () => 1
const b = () => 2
const c = () => 3
if (a === 1) {
    this.setState({count: this.state.count + 1});
}
if (b === 2) {
    this.setState({count: this.state.count + 1});
}
if (c === 3) {
    this.setState({count: this.state.count + 1});
}
```

Не смотря, на то, что setState вызывается в условных блоках и результат возвращается синхронной функцией setState 
вызывается в одном событии или жизненном цикле по этому, состояние может измениться только один раз, так как все вызовы 
могут быть объединены. В результате, если ``count`` было, например ``0`` то после трех вызовов setState значение 
станет ``1``

**Пример для классового компонента с функциональным обновлением:**
```javascript
this.setState((prevState) => ({ count: prevState.count + 1 }));
this.setState((prevState) => ({ count: prevState.count + 1 }));
this.setState((prevState) => ({ count: prevState.count + 1 }));
```

Здесь каждое обновление будет использовать актуальное состояние на момент вызова. В результате, если count было, 
например, 0, то после трех вызовов setState значение станет 3, так как каждый раз prevState будет увеличиваться на 1.
