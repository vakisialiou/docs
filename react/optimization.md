### Как можно оптимизировать производительность React-приложений?

1. [React.memo](../demo/src/optimization-examples/FuncMemo.jsx) — предотвращает лишний рендеринг компонента, если его 
пропсы не изменились.
2. [PureComponent](../demo/src/optimization-examples/ClassMemo.jsx) — используется в классовых компонентах для контроля 
обновлений компонентов.
3. [shouldComponentUpdate](../demo/src/optimization-examples/ClassMemo.jsx) — используется в классовых компонентах 
для контроля обновлений компонентов.
4. [useMemo](../demo/src/hook-examples/ExpensiveCalculationUseMemo.jsx) — мемоизирует результат вычисления и 
использует его при рендере, если зависимости не изменились.
5. [useCallback](../demo/src/hook-examples/CounterUseCallback.jsx) — мемоизирует функции, чтобы не пересоздавать их 
при каждом рендере.
6. [useTransition](../demo/src/hook-examples/ListUseTransition.jsx) — позволяет более плавно переключать интерфейс 
при выполнении тяжёлых задач.

### Как работают React.memo и PureComponent?
React.memo и PureComponent предназначены для оптимизации производительности в React, предотвращая ненужные перерисовки 
компонентов. Они работают на основе различий в состоянии и свойствах компонентов.

- **React.memo** — это функция высшего порядка, которая оборачивает функциональный компонент. Она предотвращает 
перерисовку компонента, если его пропсы не изменились.
  - По умолчанию делает поверхностное сравнение пропсов. Это означает, что, если пропс — это объект или массив, и его 
  ссылка не изменилась, React.memo не перерисует компонент, даже если содержимое этого объекта или массива изменилось.
  - Для глубокого сравнения объектов или массивов можно передать второй аргумент. Это функция, которая описывает 
  условия и возвращает ``true|false``.
- **PureComponent** - это базовый класс для создания классовых компонентов, который автоматически реализует метод 
shouldComponentUpdate с поверхностным сравнением пропсов и состояния.
  - Делает поверхностное сравнение, поэтому для сложных объектов, содержащихся в пропсах или состоянии, это может быть 
  неэффективно. Если вы изменяете объект или массив, необходимо создавать новые экземпляры этих объектов или массивов, 
  чтобы PureComponent сработал.
  - Для глубокого сравнения объектов или массивов можно переопределить метод ``shouldComponentUpdate`` и описать логику 
  сравнения.


### Что такое ленивый рендеринг (lazy loading) и как его использовать в React?
Ленивый рендеринг (lazy loading) в React — это техника, позволяющая откладывать загрузку и рендеринг компонентов до 
тех пор, пока они не понадобятся, тем самым улучшая производительность приложения и сокращая время загрузки.

#### Как использовать ленивый рендеринг в React?
В React для ленивого рендеринга можно использовать динамический импорт и функцию ``React.lazy`` вместе с компонентом 
``Suspense``.

**Пример:**

```javascript
import React, { Suspense, lazy } from 'react'
const LazyComponent = lazy(() => import('./MyComponent'))

function App() {
    return (
        <div>
            <h1>Lazy Loading Example</h1>
            <Suspense fallback={<div>Loading...</div>}>
                <LazyComponent />
            </Suspense>
        </div>
    )
}

export default App
```

### Когда использовать ленивый рендеринг?
- Когда ваш компонент тяжелый или имеет много зависимостей.
- Когда приложение состоит из множества компонентов, но все они не нужны сразу при загрузке.
- При работе с маршрутизацией, когда вы хотите загружать страницы по мере необходимости.
