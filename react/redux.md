
### Что такое Redux Toolkit и чем он лучше старого Redux?

**Redux Toolkit (RTK)** — это официальная рекомендуемая библиотека для Redux, которая упрощает управление 
состоянием, устраняя многие сложности классического Redux.

**Redux Toolkit лучше, потому что:**

- ✅ Уменьшает кол-во кода.
- ✅ Позволяет изменять состояние напрямую (Immer.js).
- ✅ Встроенная поддержка асинхронных экшенов (createAsyncThunk).
- ✅ Упрощает настройку store (автоматически подключает middleware).
- ✅ Подключает Redux DevTools без дополнительной настройки.

### Как работает createSlice и configureStore?

**createSlice** — это высокоуровневая функция для создания слайсов состояния, экшенов и редюсеров. 
Это упрощает код, потому что она автоматически генерирует экшены и редюсеры, минимизируя кол-во кода.

**configureStore** - используется для конфигурирования хранилища Redux (store). Он упрощает настройку, 
включая автоматическое подключение полезных middleware (например, redux-thunk и redux-devtools), и 
позволяет задать редюсеры для каждого слайса.

### Что делает createAsyncThunk, и как обрабатывать ошибки в асинхронных экшенах?

**createAsyncThunk** - это вспомогательная функция, предоставляемая Redux Toolkit, для упрощения работы 
с асинхронными операциями в Redux, такими как API запросы. Это позволяет легко интегрировать асинхронный 
код с Redux без необходимости вручную создавать экшен-креаторы и редюсеры.

Когда вы используете `createAsyncThunk`, она автоматически генерирует три экшена для асинхронной операции:

**Pending** — когда асинхронная операция ещё не завершена.
**Fulfilled** — когда асинхронная операция завершена успешно.
**Rejected** — когда асинхронная операция завершена с ошибкой.

### Почему в RTK immer позволяет изменять state "напрямую"?

**Immer** — это библиотека для работы с иммутабельными данными, которая предоставляет API для работы с 
изменяемыми структурами данных, но на самом деле под капотом она делает копию этих данных и изменяет её, 
а не оригинал. Это обеспечивает иммутабельность, при этом код становится чище и проще.

Когда вы изменяете состояние в редьюсере с использованием Immer (что происходит в Redux Toolkit автоматически), 
вы фактически работаете с "прокси-объектом". Immer отслеживает изменения и, когда редьюсер завершает свою 
работу, сохраняет только изменения, применяя их к копии состояния. Таким образом, вы можете писать код, который 
выглядит как изменение состояния "напрямую", но под капотом Immer создает новый объект состояния, что сохраняет 
принцип иммутабельности.

### В чем разница между useSelector и useStore?

**useSelector** - используется для извлечения данных из состояния Redux. Он позволяет вам получать значения из 
состояния, которое хранится в хранилище Redux.

**useStore** - дает вам доступ к самому Redux store. Вы можете использовать его для выполнения различных операций 
с состоянием, например, для получения всего состояния, вызова экшенов и т.д.

### Как избежать лишних ререндеров при использовании useSelector?

- **Использование мемоизации (например, reselect)**
  - `reselect` - создает мемоизированные селекторы, которые перезапускаются только при изменении входных данных, 
  предотвращая ненужные пересчеты.
- **Использование второго аргумента в useSelector (shallowEqual)**
  - React-Redux предоставляет второй аргумент для useSelector — это функция сравнения (например, `shallowEqual`), 
  которая помогает избежать ререндеров, если возвращаемые данные не изменились. shallowEqual делает поверхностное 
  сравнение объектов, и если объект не изменился, рендер не будет выполнен. 
  ```js
  import { useSelector, shallowEqual } from 'react-redux';

  const Component = () => {
  const user = useSelector(state => state.user, shallowEqual);
  
  return <div>{user.name}</div>;
  }
  ```

### Почему этот код приводит к лишним ререндерам? Как его исправить?
```js
const someValue = useSelector(state => state.someSlice);
```
