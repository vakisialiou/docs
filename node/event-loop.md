[Назад](../README.md)

### Опишите цикл событий Node.js.

Цикл событий (Event Loop) в Node.js — это механизм, который позволяет обрабатывать асинхронные операции, 
не блокируя выполнение кода.

#### Фазы жизненного цикла

Цикл событий проходит через несколько фаз, и каждая из них имеет свою очередь задач (callback queue). 
Вот как это работает, шаг за шагом:

1. Синхронный код:
    - Node.js сначала выполняет весь синхронный код. Все инструкции выполняются в порядке их появления.
2. Асинхронные задачи:
   - Когда встречается асинхронная операция (например, запрос к серверу или установка таймера), Node.js "отправляет" 
её на выполнение и продолжает обработку следующего синхронного кода, не дожидаясь завершения асинхронной задачи.
   - Колбэк, связанный с этой асинхронной задачей, не выполняется сразу.
   - Когда задача завершится колбэк помещается в соответствующую очередь задач (callback queue).
3. Фазы цикла событий:
   - Цикл событий проходит через фазы, на каждой из которых обрабатываются определённые задачи. 
Вот основные фазы:
   1. [x] Timers
      - На этой фазе обрабатываются колбэки, установленные с помощью setTimeout и setInterval.
      - Если время таймера истекло, соответствующий колбэк выполняется.
   2. [x] Pending Callbacks
      - Здесь обрабатываются колбэки, которые были отложены после завершения некоторых системных операций, 
таких как завершение I/O операций. Если моя асинхронная функция выполняет http запрос и произошел разрыв TCP 
соединения то, колбэк попадет в эту фазу т.к. это системное событие, которое не связано напрямую с завершением 
основного ввода-вывода.
   3. [x] Idle, Prepare
      - Внутренние фазы, используемые Node.js для подготовки к следующим операциям. Обычно эти фазы не требуют 
вмешательства разработчика.
   4. [x] Poll
      - Эта фаза отвечает за обработку I/O операций. Если есть колбэки, которые ждут обработки, они выполняются 
на этой фазе. Если моя асинхронная функция выполняет http запрос и удалённый сервер вернул статус 500, то колбэк 
будет выполнен в этой фазе, поскольку это завершённая HTTP операция.
      - Если нет ожидающих I/O операций, Node.js может оставаться в этой фазе, ожидая новых событий.
   5. [x] Check
      - В этой фазе выполняются колбэки, зарегистрированные с помощью setImmediate.
      - Это позволяет выполнять определённые задачи после фазы Poll, но перед началом следующей итерации цикла.
   6. [x] Close Callbacks
      - Эта фаза выполняет колбэки, связанные с закрытием ресурсов (например, http, socket, stream).
4. Обработка колбэков:
   - Когда цикл событий достигает фазы, в которую попала задача из очереди, Node.js извлекает колбэк из 
очереди и выполняет его.
   - Если есть несколько колбэков в очереди, они обрабатываются по очереди.
5. process.nextTick():
   - Эта функция позволяет зарегистрировать колбэк, который будет выполнен между текущей операцией и следующей фазой 
цикла событий. Это означает, что колбэк process.nextTick выполнится сразу после текущего выполнения кода, 
но до выполнения любого другого колбэка из очереди.

#### Пояснение. Взаимодействие фаз цикла событий и очередей задач.

В Node.js есть как фазы цикла событий, так и различные очереди задач. Эти два механизма тесно связаны 
между собой. А точнее, каждая фаза цикла событий отвечает за свою очередь задач, и в каждой фазе обрабатываются 
определённые типы задач.

**Как это работает?**
- **Фазы цикла событий** — это этапы, через которые проходит Node.js, обрабатывая задачи. Каждая фаза имеет 
своё предназначение и отвечает за выполнение определённого типа задач (таймеры, I/O операции, колбэки и т.д.).
- **Очереди задач** — это те самые колбэки (задачи), которые были зарегистрированы на выполнение 
(например, setTimeout(), I/O задачи, setImmediate(), и т.д.). Эти колбэки накапливаются в разных очередях 
в зависимости от того, какой механизм их поставил (таймеры, I/O, обещания, и т.д.).

### Как цикл событий управляет асинхронными операциями в Node.js?
- **Запуск программы:** Node.js запускает твой код, выполняя синхронные операции немедленно.
- **Асинхронные операции:** Когда возникает асинхронная операция (например, чтение файла или HTTP-запрос), 
она запускается и сразу же уходит "в сторону". Node.js не ждет её завершения и продолжает выполнение следующего кода.
- **Обратные вызовы (callbacks):** Когда асинхронная операция завершается, её колбэк (функция обратного вызова) 
помещается в специальную "очередь задач".
- **Цикл событий:** Цикл событий проходит через несколько фаз в фиксированном порядке. 
Он проверяет задачи в очереди для каждой фазы, чтобы выяснить, какие колбэки можно выполнить.
- **Проверка фаз:**
  - На каждой фазе (например, Timers, I/O Callbacks, Poll, Check) цикл событий проверяет, 
есть ли задачи в соответствующем списке задач для этой фазы.
  - Если задачи есть, цикл берет колбэк из очереди и выполняет его.

### Как цикл событий влияет на производительность приложения Node.js?
1. Неблокирующий ввод-вывод
   - Node.js позволяет выполнять другие задачи, не дожидаясь завершения операций 
(например, чтения файлов или сетевых запросов). Это позволяет обрабатывать множество запросов одновременно.
2. Эффективное использование ресурсов
   - Вместо создания новых потоков для каждого запроса, Node.js использует один поток для всех операций, 
что снижает затраты на память и процессор.
3. Отзывчивость
   - : Благодаря быстрой обработке асинхронных задач, приложения остаются отзывчивыми даже при высокой нагрузке.


### Если в Node.js асинхронные функции не блокирует выполнение скрипта значит они выполняются в отдельном потоке?
Асинхронные функции в Node.js не выполняются в отдельном потоке в прямом смысле, а используют пул потоков 
для выполнения длительных операций, позволяя основному потоку оставаться свободным и продолжать выполнять другие задачи.

- Когда вы вызываете асинхронную функцию (например, fs.readFile() для чтения файла), Node.js передает 
эту операцию на выполнение в фоновую систему. В большинстве случаев это происходит через механизм, 
предоставляемый операционной системой, который может включать многопоточность.
- Если операция является блокирующей (например fs.readFileSync()) или если количество одновременных I/O операций 
превышает возможности операционной системы (например, из-за высоких нагрузок), Node.js передаст операцию на выполнение 
в пул потоков libuv.
  -  Пул потоков может содержать несколько потоков (обычно 4 по умолчанию).